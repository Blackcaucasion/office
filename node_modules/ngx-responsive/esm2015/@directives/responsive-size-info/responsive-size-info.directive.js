import { __decorate } from "tslib";
/**
 * @name responsive-size-info.directive
 * @description Responsive Size Info directive in ngx-responsive
 *
 * @license MIT
 */
import { Directive, EventEmitter, Input, Output, ViewContainerRef, OnInit, OnDestroy, ChangeDetectorRef } from '@angular/core';
import { ResponsiveState } from '../../@core/providers/responsive-state/responsive-state';
import { ResponsiveSizeInfo } from './responsive-size-info';
import { PlatformService } from '../../@core/providers/platform-service/platform.service';
let ResponsiveSizeInfoDirective = class ResponsiveSizeInfoDirective extends ResponsiveSizeInfo {
    constructor(_responsiveState, viewContainer, cd, platformService) {
        super(_responsiveState, platformService);
        this._responsiveState = _responsiveState;
        this.viewContainer = viewContainer;
        this.cd = cd;
        this.statechanges = new EventEmitter();
    }
    set responsiveSizeInfo(grid_state) {
        this._updateData(this.currentstate);
    }
    ngOnInit() {
        this.connect();
    }
    ngOnDestroy() {
        this.disconnect();
    }
    _updateData(value) {
        this.statechanges.emit(value);
        this.cd.markForCheck();
    }
};
ResponsiveSizeInfoDirective.ctorParameters = () => [
    { type: ResponsiveState },
    { type: ViewContainerRef },
    { type: ChangeDetectorRef },
    { type: PlatformService }
];
__decorate([
    Input()
], ResponsiveSizeInfoDirective.prototype, "responsiveSizeInfo", null);
__decorate([
    Output()
], ResponsiveSizeInfoDirective.prototype, "statechanges", void 0);
ResponsiveSizeInfoDirective = __decorate([
    Directive({ selector: 'responsiveSizeInfo' })
], ResponsiveSizeInfoDirective);
export { ResponsiveSizeInfoDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzcG9uc2l2ZS1zaXplLWluZm8uZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXJlc3BvbnNpdmUvIiwic291cmNlcyI6WyJAZGlyZWN0aXZlcy9yZXNwb25zaXZlLXNpemUtaW5mby9yZXNwb25zaXZlLXNpemUtaW5mby5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7OztHQUtHO0FBQ0gsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRS9ILE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSx5REFBeUQsQ0FBQztBQUMxRixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM1RCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0seURBQXlELENBQUM7QUFHMUYsSUFBYSwyQkFBMkIsR0FBeEMsTUFBYSwyQkFBNEIsU0FBUSxrQkFBa0I7SUFPL0QsWUFBbUIsZ0JBQWlDLEVBQ3pDLGFBQStCLEVBQy9CLEVBQXFCLEVBQzVCLGVBQWdDO1FBQ2hDLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRSxlQUFlLENBQUMsQ0FBQztRQUoxQixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWlCO1FBQ3pDLGtCQUFhLEdBQWIsYUFBYSxDQUFrQjtRQUMvQixPQUFFLEdBQUYsRUFBRSxDQUFtQjtRQUp0QixpQkFBWSxHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO0lBTWpCLENBQUM7SUFUdEMsSUFBSSxrQkFBa0IsQ0FBQyxVQUE2QjtRQUN6RCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBUUQsUUFBUTtRQUNKLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNuQixDQUFDO0lBQ0QsV0FBVztRQUNQLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBQ1MsV0FBVyxDQUFDLEtBQVU7UUFDNUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDOUIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUMzQixDQUFDO0NBQ0osQ0FBQTs7WUFmd0MsZUFBZTtZQUMxQixnQkFBZ0I7WUFDM0IsaUJBQWlCO1lBQ1gsZUFBZTs7QUFSM0I7SUFBUixLQUFLLEVBQUU7cUVBRVA7QUFDUztJQUFULE1BQU0sRUFBRTtpRUFBc0Q7QUFMdEQsMkJBQTJCO0lBRHZDLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxvQkFBb0IsRUFBRSxDQUFDO0dBQ2pDLDJCQUEyQixDQXNCdkM7U0F0QlksMkJBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBuYW1lIHJlc3BvbnNpdmUtc2l6ZS1pbmZvLmRpcmVjdGl2ZVxyXG4gKiBAZGVzY3JpcHRpb24gUmVzcG9uc2l2ZSBTaXplIEluZm8gZGlyZWN0aXZlIGluIG5neC1yZXNwb25zaXZlXHJcbiAqXHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuaW1wb3J0IHsgRGlyZWN0aXZlLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFZpZXdDb250YWluZXJSZWYsIE9uSW5pdCwgT25EZXN0cm95LCBDaGFuZ2VEZXRlY3RvclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgUmVzcG9uc2l2ZVN0YXRlIH0gZnJvbSAnLi4vLi4vQGNvcmUvcHJvdmlkZXJzL3Jlc3BvbnNpdmUtc3RhdGUvcmVzcG9uc2l2ZS1zdGF0ZSc7XHJcbmltcG9ydCB7IFJlc3BvbnNpdmVTaXplSW5mbyB9IGZyb20gJy4vcmVzcG9uc2l2ZS1zaXplLWluZm8nO1xyXG5pbXBvcnQgeyBQbGF0Zm9ybVNlcnZpY2UgfSBmcm9tICcuLi8uLi9AY29yZS9wcm92aWRlcnMvcGxhdGZvcm0tc2VydmljZS9wbGF0Zm9ybS5zZXJ2aWNlJztcclxuXHJcbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ3Jlc3BvbnNpdmVTaXplSW5mbycgfSlcclxuZXhwb3J0IGNsYXNzIFJlc3BvbnNpdmVTaXplSW5mb0RpcmVjdGl2ZSBleHRlbmRzIFJlc3BvbnNpdmVTaXplSW5mbyBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcclxuICAgIHB1YmxpYyBjdXJyZW50c3RhdGU6IHN0cmluZztcclxuICAgIEBJbnB1dCgpIHNldCByZXNwb25zaXZlU2l6ZUluZm8oZ3JpZF9zdGF0ZTogc3RyaW5nW10gfCBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVEYXRhKHRoaXMuY3VycmVudHN0YXRlKTtcclxuICAgIH1cclxuICAgIEBPdXRwdXQoKSBzdGF0ZWNoYW5nZXM6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBfcmVzcG9uc2l2ZVN0YXRlOiBSZXNwb25zaXZlU3RhdGUsXHJcbiAgICAgICAgcHVibGljIHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXHJcbiAgICAgICAgcHVibGljIGNkOiBDaGFuZ2VEZXRlY3RvclJlZixcclxuICAgICAgICBwbGF0Zm9ybVNlcnZpY2U6IFBsYXRmb3JtU2VydmljZVxyXG4gICAgKSB7IHN1cGVyKF9yZXNwb25zaXZlU3RhdGUsIHBsYXRmb3JtU2VydmljZSk7IH1cclxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xyXG4gICAgfVxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgX3VwZGF0ZURhdGEodmFsdWU6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc3RhdGVjaGFuZ2VzLmVtaXQodmFsdWUpO1xyXG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9XHJcbn1cclxuIl19