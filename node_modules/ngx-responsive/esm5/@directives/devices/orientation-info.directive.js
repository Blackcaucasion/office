import { __decorate, __extends } from "tslib";
/**
 * @name orientation-info.directive
 * @description Device orientation directive in ngx-responsive
 *
 * @license MIT
 */
import { EventEmitter, Directive, Output, ViewContainerRef, OnInit, OnDestroy, ChangeDetectorRef } from '@angular/core';
import { ResponsiveState } from '../../@core/providers/responsive-state/responsive-state';
import { OrientationInfo } from './orientation-info';
import { PlatformService } from '../../@core/providers/platform-service/platform.service';
var OrientationInfoDirective = /** @class */ (function (_super) {
    __extends(OrientationInfoDirective, _super);
    function OrientationInfoDirective(_responsiveState, viewContainer, cd, platformService) {
        var _this = _super.call(this, _responsiveState, platformService) || this;
        _this._responsiveState = _responsiveState;
        _this.viewContainer = viewContainer;
        _this.cd = cd;
        _this.orientation = new EventEmitter();
        return _this;
    }
    OrientationInfoDirective.prototype.ngOnInit = function () {
        this.connect();
    };
    OrientationInfoDirective.prototype.ngOnDestroy = function () {
        this.disconnect();
    };
    OrientationInfoDirective.prototype._updateData = function (value) {
        this.orientation.emit(value);
        this.cd.markForCheck();
    };
    OrientationInfoDirective.ctorParameters = function () { return [
        { type: ResponsiveState },
        { type: ViewContainerRef },
        { type: ChangeDetectorRef },
        { type: PlatformService }
    ]; };
    __decorate([
        Output()
    ], OrientationInfoDirective.prototype, "orientation", void 0);
    OrientationInfoDirective = __decorate([
        Directive({ selector: 'orientation-info' })
    ], OrientationInfoDirective);
    return OrientationInfoDirective;
}(OrientationInfo));
export { OrientationInfoDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3JpZW50YXRpb24taW5mby5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtcmVzcG9uc2l2ZS8iLCJzb3VyY2VzIjpbIkBkaXJlY3RpdmVzL2RldmljZXMvb3JpZW50YXRpb24taW5mby5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7OztHQUtHO0FBQ0gsT0FBTyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFeEgsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHlEQUF5RCxDQUFDO0FBQzFGLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNyRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0seURBQXlELENBQUM7QUFHMUY7SUFBOEMsNENBQWU7SUFFekQsa0NBQXNCLGdCQUFpQyxFQUN6QyxhQUErQixFQUMvQixFQUFxQixFQUMvQixlQUFnQztRQUhwQyxZQUlJLGtCQUFNLGdCQUFnQixFQUFFLGVBQWUsQ0FBQyxTQUFHO1FBSnpCLHNCQUFnQixHQUFoQixnQkFBZ0IsQ0FBaUI7UUFDekMsbUJBQWEsR0FBYixhQUFhLENBQWtCO1FBQy9CLFFBQUUsR0FBRixFQUFFLENBQW1CO1FBSGxCLGlCQUFXLEdBQXNCLElBQUksWUFBWSxFQUFFLENBQUM7O0lBS3ZCLENBQUM7SUFDL0MsMkNBQVEsR0FBUjtRQUNJLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNuQixDQUFDO0lBQ0QsOENBQVcsR0FBWDtRQUNJLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBQ1MsOENBQVcsR0FBckIsVUFBc0IsS0FBVTtRQUM1QixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM3QixJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQzNCLENBQUM7O2dCQWR1QyxlQUFlO2dCQUMxQixnQkFBZ0I7Z0JBQzNCLGlCQUFpQjtnQkFDZCxlQUFlOztJQUoxQjtRQUFULE1BQU0sRUFBRTtpRUFBNEQ7SUFENUQsd0JBQXdCO1FBRHBDLFNBQVMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxrQkFBa0IsRUFBRSxDQUFDO09BQy9CLHdCQUF3QixDQWlCcEM7SUFBRCwrQkFBQztDQUFBLEFBakJELENBQThDLGVBQWUsR0FpQjVEO1NBakJZLHdCQUF3QiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbmFtZSBvcmllbnRhdGlvbi1pbmZvLmRpcmVjdGl2ZVxyXG4gKiBAZGVzY3JpcHRpb24gRGV2aWNlIG9yaWVudGF0aW9uIGRpcmVjdGl2ZSBpbiBuZ3gtcmVzcG9uc2l2ZVxyXG4gKlxyXG4gKiBAbGljZW5zZSBNSVRcclxuICovXHJcbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgRGlyZWN0aXZlLCBPdXRwdXQsIFZpZXdDb250YWluZXJSZWYsIE9uSW5pdCwgT25EZXN0cm95LCBDaGFuZ2VEZXRlY3RvclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgUmVzcG9uc2l2ZVN0YXRlIH0gZnJvbSAnLi4vLi4vQGNvcmUvcHJvdmlkZXJzL3Jlc3BvbnNpdmUtc3RhdGUvcmVzcG9uc2l2ZS1zdGF0ZSc7XHJcbmltcG9ydCB7IE9yaWVudGF0aW9uSW5mbyB9IGZyb20gJy4vb3JpZW50YXRpb24taW5mbyc7XHJcbmltcG9ydCB7IFBsYXRmb3JtU2VydmljZSB9IGZyb20gJy4uLy4uL0Bjb3JlL3Byb3ZpZGVycy9wbGF0Zm9ybS1zZXJ2aWNlL3BsYXRmb3JtLnNlcnZpY2UnO1xyXG5cclxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnb3JpZW50YXRpb24taW5mbycgfSlcclxuZXhwb3J0IGNsYXNzIE9yaWVudGF0aW9uSW5mb0RpcmVjdGl2ZSBleHRlbmRzIE9yaWVudGF0aW9uSW5mbyBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcclxuICAgIEBPdXRwdXQoKSBwdWJsaWMgb3JpZW50YXRpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIF9yZXNwb25zaXZlU3RhdGU6IFJlc3BvbnNpdmVTdGF0ZSxcclxuICAgICAgICBwcm90ZWN0ZWQgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcclxuICAgICAgICBwcm90ZWN0ZWQgY2Q6IENoYW5nZURldGVjdG9yUmVmLFxyXG4gICAgICAgIHBsYXRmb3JtU2VydmljZTogUGxhdGZvcm1TZXJ2aWNlXHJcbiAgICApIHsgc3VwZXIoX3Jlc3BvbnNpdmVTdGF0ZSwgcGxhdGZvcm1TZXJ2aWNlKTsgfVxyXG4gICAgbmdPbkluaXQoKSB7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XHJcbiAgICB9XHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBfdXBkYXRlRGF0YSh2YWx1ZTogYW55KSB7XHJcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbi5lbWl0KHZhbHVlKTtcclxuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==